array：数组
	
	使用泛型：
		1、让我们的数据结构可以放置“任何”数据类型
		2、不可以是基本数据类型，只能是类对象。
			基本数据类型：boolean、byte、char、short、int、long、float、doule
		3、每个基本数据类型都有对应的包装类。
			包装类：Boolean、Byte、Character、Short、Integer、Long、Float、Double
	
	静态数组：
		数组容量不可变：Array.class
	
	动态数组：
		数组容量 可 伸缩：Array2.class
		说明：原数组大小不够时 就进行 扩容 
		
		各个方法时间复杂度分析：
			Chapter-02-watermarked.pdf
		
	简单的时间复杂度分析：
		1、O(1),O(n),O(lgn),O(nlogn),O(n^2)
		2、O描述的是算法的运行时间和输入数据之间的关系
		3、O（渐进时间复杂度）
	
stack：栈
	1、栈也是一种线性结构
	2、相比数组，栈对应的操作是数组的子集
	3、只能从一端添加元素，也只能从一端取出元素
	4、栈是一种【后进先出】(Last In First Out,LIFO)的数据结构
	【只关心栈顶】
	
	栈的应用：
		1、无处不在的Undo操作(撤销)，如word中的撤销操作：undo操作 - 编辑器
		2、程序调用的系统栈：系统调用栈 - 操作系统
			举例： 子过程子逻辑的调用在编译器内部实现的机制
				func A(){... B()① ...}
				func B(){... C()② ...}
				func C(){....③..}
			说明：先运行A()，当到了①处，立刻到B()，当到了②处，立刻到C()处； ——》相当于入栈，记录查询位置
				当C()处运行完，立刻回到B()处从②后开始执行，当B()处运行完，立刻回到A()处从①后开始执行，直到结束。——》相当于出栈
		3、括号匹配 - 编辑器
			编译器如何检查括号匹配的一个问题？也是使用一个栈
			Leetcode上面有很多问题：leetcode.com / leetcode-cn.com
			题目：给定一个只包含'(',')','{','}','[',']'的字符串，判断字符串是否有效
				如：”[]“ 有效，”(]“ 无效
			答：利用栈来解决，栈顶元素反映了在嵌套的层次关系中，最近的需要匹配的元素
			
queue:队列
	1、队列也是一种线性结构
	2、相比数组，队列对应的操作是数组的子集
	3、只能从一端(队尾)添加元素，只能从另一端(队首)取出元素
	4、 队列是一种【先进先出】(First In First Out,FIFO)的数据结构(先到先得)
	【只关系队首】
	数组队列的问题？
		删除队首元素，其他元素都要向前移动(时间复杂度O(n))
		解决方案：
			【循环队列】：
				front == tail 队列为空
				tail+1 == front  队列满(不准确)
				(tail + 1) % capacity == front 队列满
				当入队时，只需要维护tail++；出队时，只需要维护front++；这样就不需要所有元素都移动位置了，只需要front向后移动一个；O(1)
				一个【环】，准确来说tail：(当前的索引tail+1) % 整个数组的长度
	
	数组队列 / 循环队列 的效率：
		同时入队/出队 10万个随机数；考量运行时间：
			ArrayQueue Time:3.349060557 s
 			LoopQueue Time:0.020682681 s
			
Linked List:链表
	线性数据结构(动态数组、栈、队列)：底层依托静态数组；靠resize解决固定容量问题。
	
	为什么链表很重要？
		0、链表也是一种线性结构
		1、链表：是真正的动态数据结构
		2、最简单的动态数据结构(★)
		3、更深入的理解引用(或者)
		4、更深入的理解递归
		5、辅助组成其他的数据结构(图、Hash表等)
	链表：
		1、数据存储在”节点“(Node)中
			Class Node{
				E e;		// 存储的数据对象(真正的数据)
				Node next;	// 下一个节点对象的引用
			}
			如：火车(车厢里面是人，他还会连接下一个车厢)
		2、优点：真正的动态，不需要处理固定容量的问题
		3、缺点：失去了随机访问的能力
	
	数组和链表的对比：
		数组最好用于索引有语意的情况，scores[2]
		最大的优点：支持快速查询
		
		链表不适合用于索引有语意的情况
		最大的优点：动态
	★——对链表头的操作可以简化：为链表设立虚拟头节点(dummyHead) algorithm.study.linkedlist包下
	链表的时间复杂度：在增加/删除/查 下只针对链表头操作时，为O(1);这种类型类似对栈的操作，因此利用链表来实现栈
	
	(带虚拟头节点)链表实现栈：algorithm.study.linkedliststack 包下
	
	数组栈 / 链表栈 的效率：algorithm.study.linkedliststack.or.arraystack 包下
		同时入栈/出栈 10万个随机数；考量运行时间：(出现下面的情况是因为，数组在进行扩容的时候会复制来复制去；当测试数变大时，效果会反转，因为链表会创建新的Node对象。)
			ArrayStack Time:0.028222221 s
			LinkedListStack Time:0.019440426 s
	
	改进我们的链表：为了方便利用【链表实现队列】！
		不采用虚拟头节点，而是采用 head(头节点)、tail(尾节点)
		队首 == 头节点，队尾 == 尾节点
		★：从head端删除元素，从tail端插入元素。【队列：先进先出】
		注意：由于没有dummyHead，要注意链表为空的情况
	
		(不带虚拟头节点)链表实现栈：algorithm.study.linkedlistqueue 包下
	
链表与递归【重要】：
	leetcode官网203：删除链表中的元素？ algorithm.study.linkedlist.solution 包下
		实例：给定 1-->	2-->6-->3-->4-->5-->6,val = 6,
			返回  1-->	2-->3-->4-->5
	
	递归：
		1、本质上，将原来的问题，转化为更小的同一问题
		2、举例：数组求和  algorithm.study.linkedlist.solution.Sum
	
	利用递归 解决链表中删除元素的问题！		
		algorithm.study.linkedlist.solution.Solution.removeElements3()
	
	递归调用过程：
		搜索【递归解决链表中删除元素问题(步骤).png】
	
	★、递归的调用 本质上 和 子过程的调用 是没有区别的
		
	递归调用是有代价的：函数调用 + 系统栈空间
	
	双链表:
		Class Node{
			E e;			// 存储的数据对象(真正的数据)
			Node next,prev;	// 节点对象的引用(后一个 和 前一个)
		}
		
	循环链表：
		尾节点 不指向 空，而是指向虚拟节点(dummyHead)；从而形成了一个环
	
	
	
Binary Search Tree：二分搜索树
			树结构
			 	28
		16				30
	13		22		29		42	
	
	为什么要有树结构？
		1、将数据使用数结构存储后，出奇的高效
			二分搜索树（Binary Search Tree）
			平衡二叉树：AVL、红黑树	
			堆、并查集
			线段树(主要处理线段这样特殊的数据)
			Trie(字典树、前缀树；主要处理字符串这类特殊的数据)
			
	二叉树：
				 	28
			16				30
		13		22		29		42	
		
		1、和链表一样，动态数据结构
			class Node{
				E e;
				Node left;	// 左孩子
				Node right;	// 右孩子
			}			
		2、二叉树具有唯一根节点
		3、二叉树每个节点最多有两个孩子
		4、二叉树每个节点最多有一个父亲节点
		5、无孩子节点的 称为 叶子节点
		6、二叉树具有天然递归结构(★)
			每个节点的左孩子也是二叉树
			每个节点的右孩子也是二叉树
		7、二叉树不一定是“满”的
		
	二分搜索树：algorithm.study.binarysearchtree.BinarySearchTree<E>
		1、二分搜索树是二叉树
		2、二分搜索树的每个节点的值：
			·大于其左子树的所有节点的值
			·小于其右子树的所有节点的值
			这样得到的二分搜索树不包含重复元素
				若想包含重复元素的话，只需要定义：
					左子树小于等于节点 或者 右子树大于等于节点
		3、每一颗子树也是二分搜索树 
		4、存储的元素必须右可比较性(如：数字)
	
	二分搜索树添加新元素：
		1、二分搜索树添加元素的非递归写法，和链表非常像(只是多了一个比较)
		2、这里主要关注 递归的实现
	
	二分搜索树：
		广度优先遍历：层次遍历/层序遍历
		深度优先遍历：前序遍历、中序遍历、后序遍历
	
	二分搜索树的前序遍历：【根 左 右】（常用的遍历方式）
	二分搜索树的中序遍历：【左 根 右】（所有元素排序后的结果）
		说明：二分搜索树的中序遍历结果是顺序的
	二分搜索树的后序遍历：【左 右 根】
		后序遍历的一个应用：为二分搜索树释放内存
		
		二分搜索树前序遍历的非递归写法：
			借助栈(后进先出)的实现：
					 	28
				16				30
			13		22		29		42	
				
			步骤分析：先将根节点入栈【28】，再出栈[28];再将28根节点的孩子(先右孩子再左孩子)入栈【30、16】，再出栈[28,16];再将16
					节点的孩子入栈【30、22、13】，再出栈[28,16,13];再将13节点的孩子入栈，发现无孩子时，此时栈为【30、22】；再将
					22节点的孩子入栈，发现无孩子时，出栈[28,16,13,22];此时栈为【30】,再出栈[28,16,13,22,30],再将30节点的孩子
					入栈【42、29】,......
						说明：栈底【42、29】栈顶
		
		提升练习：
			二分搜索树中序遍历的非递归写法(未完成)
			二分搜索树后序遍历的非递归写法(未完成)
			参考：
				百度搜索：图解数据结构 二叉树遍历
	
	二分搜索树的层序遍历：从根节点从上往下逐层遍历，在同一层，按从左到右的顺序对节点逐个遍历		
		利用队列(先入先出)：
	
	广度优先遍历的意义：
		1、更快的找到问题的解
		2、常用于算法设计中-最短路径(无权图)
		3、图中的深度优先遍历 和 广度优先遍历
		
	二分搜索树 删除节点：
		特例：
						28
				16				30
			13		 22		29		
			   14	
		删除最小值：根节点开始向左走到底(注意它是否还有右孩子)
		删除最大值：根节点开始向右走到底(注意它是否还有左孩子)
		
		删除任意节点：
			第一种、删除只有左孩子的节点(如删除“30”节点，它只有29这个左孩子节点，直接用待删除节点的左子树取代它的位置)
			第二种、删除只有右孩子的节点(如删除“13”节点，它只有14这个右孩子节点，直接用待删除节点的右子树取代它的位置)
			第三种：删除左右都有孩子的节点(如删除“16”这个节点)
					参考 —— 1962年、Hibbard提出的-Hibbard Deletion 方法
					描述：将待删除节点看作 d
					  ①、找到 s = minimun(d->right)	—— 找到删除节点右子树中的最小节点为s
						 s 是 d 的后继节点(successor)
						 	s->right = removeMin(d->right)	——	s->right = 返回删除节点后新的二分搜索树的根
						 	s->left = d->left
						   	删除d，s是新的子树的根
					  ②、找到p = maxmun(d->left)	—— 找到删除节点左子树中的最大节点为p
						 p 是 d 的前驱节点(predecessor)
		
	二分搜索树的其他问题：【未实现】
		二分搜索树的floor 与 ceil 
			如：找出45的floor(比45小的那个最大元素) 与 ceil(比45大的那个最小元素)【寻找的这个45 可以不在二分搜索树中】
		二分搜索树的rank
			给出一个元素，问它的排名是第几？如rank(58),就是58在二分搜索树中相应的排名
		二分搜索树的select
			找出一个排名的元素，如select(10),就是在二分搜索树中找出排名为10的元素
		说明：在实现rank和select时，Node最好维护一个size(一个节点包含多少个下级节点，如28这个节点的size = 7)
		
		
		
集合和映射(Set and Map):
	集合(Set)：不能添加重复元素
		基于【二分搜索树】实现 set集合
			测试BSTSet这个类：对原版书的词汇量 进行统计
				a-tale-of-two-cities.txt
				pride-and-prejudice.txt
		基于【链表】实现 set集合	
			因为：二分搜索树和链表都属于动态数据结构
				class Node{						
					E e;
					Node left;	// 左孩子
					Node right;	// 右孩子
				}			
				
				Class Node{
					E e;		// 存储的数据对象(真正的数据)
					Node next;	// 下一个节点对象的引用
				}
				
		典型应用：客户统计、词汇量统计
		
		集合的时间复杂度分析：
			对比	【二分搜索树】实现 set集合  与 【链表】实现 set集合；前者快一些
							linkedlistSet		BSTSet/平均/最差(有几个节点就有几层二叉树，解决方法是平衡二叉树)
			增(add)				O(n)			O(h,二分搜索树的高) / O(logn) / O(n)
			查(contains)			O(n)			O(h) / O(logn) / O(n)
			删(remove)			O(n)			O(h) / O(logn) / O(n)
			
			logn 和 n的差距：
						logn		n
				n=16	 4			16		相差4倍
				n=1024	 10			1024	相差100倍
			
		leetcode804：唯一摩尔斯密码词
		
		有序集合 和 无序集合
			BSTSet(基于二分搜索树) 和 java的TreeSet(基于红黑树)，他们的本质都是有序的集合。
			1、有序集合中的元素具有顺序性	——> 基于搜索树的实现
			linkedlistSet(基于链表)，它的本质是无序集合
			2、无序集合中的元素没有顺序性	——> 基于哈希表的实现
			
		多重集合：
			集合中的元素可以重复
		
	映射 Map：
		类似这样的结构       字典 ： 单词——> 释意	
		Map<k,v>
		
		基于【链表】实现 map映射
		基于【二分搜索树】实现 map映射
		
		映射的时间复杂度分析：
			对比	【二分搜索树】实现 map映射  与 【链表】实现  map映射；前者快一些
			
							linkedlistMap		BSTMap/平均/最差(有几个节点就有几层二叉树，解决方法是平衡二叉树)
			增(add)				O(n)			O(h,二分搜索树的高) / O(logn) / O(n)
			查(contains)			O(n)			O(h) / O(logn) / O(n)
			查(get)				O(n)			O(h) / O(logn) / O(n)
			删(remove)			O(n)			O(h) / O(logn) / O(n)
			改(set)				O(n)			O(h) / O(logn) / O(n)
		
		有序映射 和 无序映射
			1、有序映射中的键具有顺序性	——> 基于搜索树的实现
			2、无序映射中的键没有顺序性	——> 基于哈希表的实现
		
	集合与映射的关系：
		练习：用映射包装成集合类？未实现	
		
		leetcode349：两个数组的交集
			实例：nums1 = [4,9,5]		nums2 = [4,9,8,9,4]
				输出：[4,9]	—— 说明：输出结果中的每一个元素一定是唯一的
		
		leetcode350：两个数组的交集2(这个是考虑重复元素的)
		

堆和优先队列：
	什么是优先队列？
		普通队列：先进先出，后进后出
		优先队列：出队顺序和入队顺序无关，和优先级相关。
	为什么使用优先队列？
		【动态】选择优先级最高的任务执行	

		优先队列
							入队			出队(拿出最大的元素)
			普通线性结构		O(1)		O(n)
			顺序线性结构		O(n)		O(1)
				(可以选择 动态数组/链表 去实现这个——未实现)
			堆				O(logn)		O(logn)
	
	二叉堆：Binary Heap
				62
			41		30
		 28   16  22  13
		19
		特殊性质：
			补充说明：满二叉树，除了叶子节点，所有的节点左右孩子都不为空
			1、二叉堆是一颗完全二叉树(完全二叉树：不一定是满二叉树，但是缺失部分只能在右子树)
			2、完全二叉树：把元素顺序排列成树的形状(一层一层地放)
			3、堆中某一个节点的值 总是 不大于 其父节点的值
				—— 父节点 >= 孩子节点 ——(最大堆)
				—— 父节点 <= 孩子节点 ——(最小堆)

		用数组存储二叉堆
		  62 41 30 28 16 22 13 19
          0  1  2  3  4  5  6  7 		——> 索引
			数组相关的操作：
			parent(i) = (i-1) / 2;			——>如需要知道索引5的父亲，(5 - 1) / 2 = 2(整除)	
			left child(i) = 2 * i + 1		——>如需要知道索引1的左孩子，2 * 1 + 1 = 3
			right child(i) = 2 * i + 2		——>如需要知道索引1的右孩子，2 * 1 + 2 = 4

			向堆中添加元素：sift up
				在数组的最后添加元素，必须维护堆的性质(画图理解) —— add时间复杂度O(logn)
			向堆中取出元素：sift down
				删除数组的第一个元素，必须维护堆的性质(画图理解) —— extractMax时间复杂度O(logn)
				
			Heapify：
				将任意数组整理成堆的形状 
				数组：15 17 19 13 22 16 28 30 41 62
								15
						17				19
					13		22		16		28
				 30	  41  62
				分解：可以先将数组直接看作一颗完全二叉树(它不是堆，不满足堆的性质)；对于这样一个完全二叉树，我们从最后一个非叶子节点(22)开始计算，倒着从后向前不断进行
					sift down下沉这个操作。会遇到一个经典的问题：如何定位最后一个非叶子节点的索引？如这里的22节点
													答：只要拿到最后一个节点的索引，然后根据这个索引计算它的父亲节点的索引是谁就好了。
					我们从这个非叶子节点(22)开始向前遍历每一个节点所在的索引进行sift down操作。
					对于的步骤：索引为4的这个节点(22)进行下沉操作，看22的左右孩子，此时它只有左孩子62，发现比它还大，进行交换位置。变成索引4为62；
							然后到索引3的这个节点(13)进行下沉操作，以此类推！
				说明：
					将n个元素逐个插入到一个空堆中，算法复杂度是O(nlogn)
					Heapify的过程，算法复杂度为O(n)
					
			replace：
				取出最大元素后，放入一个新元素
				实现：可以先extractMax，再add,两次O(logn)操作
				实现：可以直接将堆顶元素直接 替换为新的元素，再进行Sift down，一次O(logn)操作。				
	
	priorityQueue(优先队列):
		出队顺序和入队顺序无关，和优先级相关
		基于【最大堆】 实现优先队列：
						
		优先队列的经典问题：
			在1000000个元素中选出前100名？ ——> 在N个元素中选出前M个元素(M < N)
				解决方法：1、对其排序后再取出，NlogN	
						2、使用优先队列，NlogM     ✔
				
			使用优先队列，维护当前看到的前M个元素；（定义 值越小，优先级越高）
					需要使用最小堆，未实现
			
	leetcode347:前k个高频元素
		示例：[1,1,1,2,2,3]，k=2，返回[1,2]


线段树(区间树) Segment Tree：
	为什么要使用线段树？
		最经典的线段树问题：区间染色、
			说明：m次操作后，我们可以在[i,j]区间内看见多少种颜色？
							使用数组实现	使用线段树(也是一种二叉树的结构)
			染色操作(更新区间)		O(n)	O(logn)
			查询操作(查询区间)		O(n)	O(logn)
	
	还有另一类经典问题：区间查询 
		实质：基于区间的统计查询
			如：2017年注册用户中消费最高的用户？消费最少的用户？等问题
		对于给定区间：
			32 26 17 55 72 19 8 46 22 68
			0  1  2  3  4  5  6  7  8 9
		更新：更新区间中一个元素或者一个区间的值，如[2,3]将这个区间的值都加1
		查询：查询一个区间[i,j]的最大值、最小值或者区间数字和
	
	举例：以求和为例，搜索【什么是线段树.png】
	
	1、线段树不是完全二叉树
	2、线段树是平衡二叉树
	3、堆也是平衡二叉树

	数组实现：
		如果区间有n个元素，数组表示需要有多少个节点？
			需要4n的空间。
		我们的线段树不考虑添加元素，即区间固定，使用4n的静态空间即可。

		创建线段树：nums = {-2,0,3,-5,2,-1}; 求和
		线段树中的区间查询[2,5]
		
		leetcode303:区域和检索-不可变
			例如：nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()
				sumRange(0, 2) -> 1
				sumRange(2, 5) -> -1
				sumRange(0, 5) -> -3
			解决方案：	
				1、利用线段树来解决。algorithm.study.segmenttreesolution.NumArray
				2、借助sum[]数组来解决，不使用线段树。algorithm.study.segmenttreesolution.NumArray2
					因为这里的数据是不可变(静态的)，所以可以不使用线段树
		
		leetcode307. 区域和检索 - 数组可修改
			示例：Given nums = [1, 3, 5]
				sumRange(0, 2) -> 9
				update(1, 2)
				sumRange(0, 2) -> 8
			解决方案：
				1、不利用线段树。algorithm.study.segmenttreesolution.NumArray3
					性能非常慢，因为当存在多个update时，就会有多少个O(n)的操作
				2、利用线段树。algorithm.study.segmenttreesolution.NumArray4
		
		补充：[未实现]
			对于一个区间进行更新:如将[2,5]区间中所有元素+3? —— 懒惰更新
		以上讲的是：一维线段树，还存在二维线段树
		以上讲的是：静态线段树(数组)，还有动态线段树(链表)
		区间操作相关另外一个重要的数据结构：
			树状数组(Binary Index Tree)
		区间相关的问题：
			RMQ(Range Minimum Query)



字典树/前缀树：Trie 
	什么是Trie?
		查询每个条目的时间复杂度和字典中一共有多少条目无关；
		时间复杂度为O(w):w为查询单词的长度
	
	// 每个节点有若干指向下个节点的指针
	class Node{
		char c; // 这个char可以不存，因为next映射里面有
		boolean isWord; // 当前这个节点是否表示一个单词的结尾，不能以叶子节点为结尾(pan 与 panda,叶子节点为a，n不是叶子节点)
		Map<char,Node> next;
	}

	Trie和前缀搜索：
		
	leetcode208. 实现 Trie (前缀树)
		示例：Trie trie = new Trie();
			trie.insert("apple");
			trie.search("apple");   // 返回 true
			trie.search("app");     // 返回 false
			trie.startsWith("app"); // 返回 true
			trie.insert("app");   
			trie.search("app");     // 返回 true

	leetcode211. 添加与搜索单词 - 数据结构设计
		设计一个支持以下两种操作的数据结构：
			void addWord(word)
			bool search(word)	// 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。
		示例:
			addWord("bad")
			addWord("dad")
			addWord("mad")
			search("pad") -> false
			search("bad") -> true
			search(".ad") -> true
			search("b..") -> true
			
	leetcode677. 键值映射
		实现一个 MapSum 类里的两个方法，insert 和 sum。
		对于方法 insert，你将得到一对（字符串，整数）的键值对。字符串表示键，整数表示值。如果键已经存在，那么原来的键值对将被替代成新的键值对。
		对于方法 sum，你将得到一个表示前缀的字符串，你需要返回所有以该前缀开头的键的值的总和。
		示例：
			输入: insert("apple", 3), 输出: Null
			输入: sum("ap"), 输出: 3
			输入: insert("app", 2), 输出: Null
			输入: sum("ap"), 输出: 5
	
	利用Trie实现词频功能：algorithm.study.triesolution.WordCount
		
	词频性能对比：基于 【二分搜索树】实现映射Map   与      基于【java提供的TreeMap】实现Trie; Trie更快
		algorithm.study.triesolution.Main
	
	Trie的删除操作：
		algorithm.study.trie.Trie.remove(String) 
		
	Trie局限性：
		最大的问题：空间！	
		改进可以利用：压缩字典树(Compressed Trie)，搜索【压缩字典树.jpg】
				     三分搜索树(Ternary Search Trie),只有左中右三个孩子(节省空间，失去一点时间)
				     后缀树
	更多字符串问题：✔
		★字串查询算法：KMP、Boyer-Moore、Rabin-Karp
		★文件压缩算法：Huffman(哈夫曼树)
		★模式匹配算法：


并查集(Union Find)：
	一种不一样的树形结构(上面的树结构都是由父亲指向孩子，但是并查集则是由孩子指向父亲；这种奇怪的树结构可以高效得回答这类问题“连接问题(Connectivity Problem)”)
	并查集可以非常快的判断：网络中节点间的连接状态
		网络是个抽象的概念：用户之间形成的网络(如：微信好友，也许AB两个用户不认识，但是可以通过共同的好友进行认识；还要其他问题：航班、公交车、等问题)
	数学中的集合类实现(如：求两个集合的并集)
	
	连接问题和路径问题：
	
	对于一组数据，主要支持两个动作：
		union(p,q)	—— 并，传入两个数据p、q，然后在并查集内部将这两个数据、以及所在的集合给合并起来
		isConnected(p,q) —— 查询两个给定的数据，他们是否属于同一个集合
			find(p) == find(q) 查找集合的id(将我们查询的p或者q这些元素，每个元素背后所对应那个集合的id是谁？也抽象成函数find());复杂度O(1)
	
	并查集的基本数据表示
		0	1	2	3	4	5	6	7	8	9	——>	0-9 表示10个不同的数据，这是抽象的表示(10个编号可能时10个人、10本书)；但是在并查集的内部我们存0-9这10个编号，它表示具体的元素(每个元素并查集存储的一个所属的集合id)
		—————————————————————————————————————
		0	0	0	0	0	1	1	1	1	1	——>	编号0-4 所对应的id为0，编号5-9所对应的id为1；不同的id值 可以理解成不同的集合所对应的编号。
		
		也可表示成：
		0	1	2	3	4	5	6	7	8	9	——> id(1与3 是属于同一个集合，对应id为1)
		—————————————————————————————————————	
		0	1	0	1	0	1	0	1	0	1	——> 也可以理解成组号
		
		实现：algorithm.study.unionfind.UnionFind1
		
		union(p,q) , O(n)——需要优化
		isConnected(p,q) , O(1)
		
	将每个元素看做一个节点：
		如：
			5				2
		6		7		3		1
		说明：这里由两棵树，2和5这个节点自己本身存在一个指向自己的指针。
			现在如果需要将7这个元素与2这个元素合并(做法：让7所在的这棵树的根节点“5”，去指向2这个节点就好了);让7这个元素与3这个元素合并的结果与前面的结果一样
										2
						 		  5	    3	 1
							  6     7
							
			0	1	2	3	4	5	6	7	8	9	——> parent
			—————————————————————————————————————
			0	1	2	3	4	5	6	7	8	9
		
			现在存在10棵树。也就是一篇森林（都指向自己）
			0	1	2	3	4	5	6	7	8	9	
			
			Union(2,3)	——>		0	1	2	4	5	6	7	8	9	
										3
										
				       数组说明——>		0	1	2	3	4	5	6	7	8	9	——> parent
								—————————————————————————————————————
								0	1	2  [2]	4	5	6	7	8	9
			
			Union(3,7)	——>		0	1	2	4	5	6	7	8	9
									  3	  7
									  
				      数组说明——>		0	1	2	3	4	5	6	7	8	9	——> parent
								—————————————————————————————————————
								0	1	2  [2]	4	5	6  [3]	8	9
			
						简要说明：实现找到3的父亲节点——>2,然后让7指向3——> [3]
		
		union(p,q) , O(h)
		isConnected(p,q) , O(h)
			algorithm.study.unionfind.UnionFind2
		
	对比：UnionFind1 与 UnionFind2，查看性能区别？
		algorithm.study.unionfind.Main.testUF(UnionFind, int)
		
		UnionFind2存在的问题：在一些极端的情况下我们得到的这颗树是链表的形式，如：
									0	1	2	4	5	6	7	8	9
									
				Union(0,1)	——>			1	2	4	5	6	7	8	9
										0
										
				Union(0,2)	——>				2	4	5	6	7	8	9
											1
											0
				Union(0,3)	——>	。。。。。
			解决方案：基于size的优化(考虑当前这棵树它整体有多少个节点)
				通俗来说就是：[让节点个数小的那课树的根节点] 【去指向】 [节点个数多的那课树的根节点] 	——> (小 指向 多)
				algorithm.study.unionfind.UnionFind3
			
		继续加深优化：
			基于rank的优化(rank其实就是指树的高度/树的深度；但不是正在意义上的高度)
				rank[i] 表示根节点为i的树的高度
				algorithm.study.unionfind.UnionFind4
			
			路径压缩：Path Compression
				所解决的问题就是 —— 让一颗比较高的树能够压缩成为一颗比较矮的树
				路径压缩发生在 find 这个操作上面：parent[p] = parent[parent[p]];
					例如：
							0
						   1
						  2
						 3
						4
						
					find(4):原先是一级一级往上找，直到找到根节点
						现在在找的过程中执行一句：parent[p] = parent[parent[p]];
							0
						   1
						  2
						 3 4
							现在执行到2了，2 也不是根节点，继续执行parent[p] = parent[parent[p]];
								0
							  1   2
							     3  4
							     现在树的深度降低，现在遍历0，发现0为根节点；它就是4的根节点
				algorithm.study.unionfind.UnionFind5
				
				再度继续优化：路径压缩：Path Compression
							0
						   1
						  2
						 3
						4
						优化成：
								0
							1 2 3 4 
					algorithm.study.unionfind.UnionFind6
			
			说明：UnionFind5	比 UnionFind6 快一些，原因在于UnionFind6包含了递归操作
		
		

平衡二叉树 与 AVL树：
	引入说明：
		二分搜索树：
			1、二分搜索树是二叉树
			2、二分搜索树的每个节点的值：
				·大于其左子树的所有节点的值
				·小于其右子树的所有节点的值
				这样得到的二分搜索树不包含重复元素
					若想包含重复元素的话，只需要定义：
						左子树小于等于节点 或者 右子树大于等于节点
			3、每一颗子树也是二分搜索树 
			4、存储的元素必须右可比较性(如：数字)
						28
				16				30
			13		22		29		42
			
		堆：
			补充说明：满二叉树，除了叶子节点，所有的节点左右孩子都不为空
			1、二叉堆是一颗完全二叉树(完全二叉树：不一定是满二叉树，但是缺失部分只能在右子树)
			2、完全二叉树：把元素顺序排列成树的形状(一层一层地放)
			3、堆中某一个节点的值 总是 不大于 其父节点的值
				—— 父节点 >= 孩子节点 ——(最大堆)
				—— 父节点 <= 孩子节点 ——(最小堆)
					62
				41		30
			 28   16  22  13
			19
		
		满二叉树：
			除了叶子节点，所有的节点左右孩子都不为空
			
		完全二叉树：
			不一定是满二叉树，但是缺失部分只能在右子树
		
		线段树：
			1、线段树不是完全二叉树
			2、线段树是平衡二叉树
			3、堆也是平衡二叉树
			
		
	回忆二分搜索树的问题：如果我们的数据是顺序添加进二分搜索树，那么我们的二分搜索树会退化成一颗链表
			1 2 3 4 5 6
				如：	1
						2
							3
								4
									5	
										6
				
			
	AVL就是一种最常见的平衡二叉树；
	AVL：
		对于任意一个节点，左子树和右子树的高度差不能超过1。
		平衡二叉树的高度和节点数量之间的关系也是O(logn)
		如：
						  12
					8			18
				5		11	17
			4
			这就是一颗平衡二叉树，但是显然这样的情况不会出现在【堆 和 线段树】这两种树结构中；
				节点【12】，左子树的高度为3，右子树的高度为2；左子树右子树的高度差为：3-2=1，满足上面说的。
			现在根据二分搜索树的性质向上面这颗树中添加两个元素2、7
								  12
							8			18
						5		11	17
					4		7
				2
			说明：上面这颗树已经不是一颗平衡二叉树了，在节点【8】，左子树的高度为3，右子树的高度为1；左子树右子树的高度差为：3-1=2，打破了平衡二叉树的条件
				此时这颗树 向左偏移，应当关注右边子树的情况，
		
				对于之前的二分搜索树来说，我们实现平衡二叉树，相应的我们对每个节点记录下这个节点所在的高度；
					如：上面这课树：节点【2】的高度为1，节点【4】的高度为2，节点【7】的高度为1；节点【5】的高度为3(只有两颗子树中最高的那课树的高度+1)。
			平衡因子：对与每一个节点而言，它的左右子树的高度差(左子树的高度-右子树的高度)
					如：节点【2】是叶子节点，它的平衡因子对于0-0=0；节点【4】，它的平衡因子对于1-0=1；.。。
				在一颗树中，一旦有一个节点的平衡因子的绝对值 > = 2时，说明这颗树就不是平衡二叉树了。

			实现：
				1、基于原来的二分搜索树去实现
					AVL树 同 二分搜索树一样，有遍历(前序、中序、后序)，最大值与最小值，插入与删除等操作；除插入与删除与二分搜索树不同外(插入与删除需要维护平衡性)，其余的操作一样。
				2、几个比较重要的辅助函数：
					1、计算节点的高度和平衡因子
						algorithm.study.avltree.AVLTree.getHeight(Node)
						algorithm.study.avltree.AVLTree.getBalanceFactor(Node)
					2、检查二分搜索树的性质和平衡性
						algorithm.study.avltree.AVLTree.isBST()
						algorithm.study.avltree.AVLTree.isBalanced()
				3、AVL树的左旋转和右旋转(维护自平衡)
					在什么时候维护平衡？
						加入节点后，沿着节点方向上维护平衡性
						例如：
							依次插入 ：12 8 5
										12
									8
								5
								此时：5的平衡因子为0；8的平衡因子为1；12的平衡因子为2(2-0)；破环了平衡性
							
							在如下树中插入节点2后，
												12
										8				18
									5		11		17
								4		7
							2
								此时：2的平衡因子为0；4的平衡因子为1；5的平衡因子为1(2-1)；8的平衡因子为2(3-1)；破话了平衡性
								
						这个情况下需要进行：
							右旋转		说明：插入的元素在不平衡的节点的左侧的左侧
								原始：此时y节点为不平衡节点也为这课树的根节点，假设他们都存在右节点【T1 T2 T3 T4】
											[y]
										x		T4
									z		T3
								T1	  T2
								说明：因为满足二分搜索树的性质；所以，T1 < z < T2 < x < T3 < y < T4
								做右旋操作：	
									步骤： x.right = y
										 y.left = T3	
										 并且x为这颗树的新的根节点
											x
									z				y
								T1		T2		T3		T4
								
							左旋转		说明：插入的元素在不平衡的节点的右侧的右侧	
								原始：此时y节点为不平衡节点也为这课树的根节点，假设他们都存在右节点【T1 T2 T3 T4】
										y
									T1		x
										T2		z	
											T3		T4	
									说明：因为满足二分搜索树的性质；所以，T1 < y < T2 < x < T3 < z < T4		
									做左旋操作：	
									步骤： x.left = y
										 y.right = T2	
										 并且x为这颗树的新的根节点
													x
											y				z
										T1		T2		T3		T4	
							上述主要讲 偏向一边的情况：
								1、插入的元素在不平衡的节点的左侧的左侧(LL)
									①、右旋转
								2、插入的元素在不平衡的节点的右侧的右侧(RR)
									①、左旋转
							但是还存在其他的情况：
								3、插入的元素在不平衡的节点的左侧的右侧(LR)
									依次插入 ：12 8 10，不平衡节点【12】
											12
										8
											10
											
									在如下树中插入节点4后，不平衡节点【8】
														12
												8				18
											5		11		17
										3		7
										  4
									实际举例：
												[y]
											x		T4
										T1	   z		
											T2 T3
										①、先对x进行左旋转，转化为LL的情况
														[y]
													z		T4
												x		T3
											T1	  T2
										②、再依照LL的情况进行处理
								4、插入的元素在不平衡的节点的右侧的左侧(RL)
										实际举例：
												[y]
											T1		x		
											   	  z		T4
											    T2 T3
										①、先对x进行右旋转，转化为RR的情况
														[y]
													T1			z	
														  	T2 		x
													   	  		  T3  T4
										②、再依照RR的情况进行处理
				4、AVL树的删除
					删除操作跟二分搜索树的逻辑一致，只是在删除后，需要对返回删除节点后新的二分搜索树的根进行平衡性质的维护
					三个步骤：
						1、更新height
						2、计算平衡因子
						3、平衡维护
							LL —— 右旋转
							RR —— 左旋转
							LR —— 先左旋转再右旋转
							RL —— 先右旋转再左旋转
		
		各种Map映射对比：
			AVLMap / LinkedListMap / BSTMap
				algorithm.study.avltree.test.TestMapMain			
		
		各种Set集合对比：
			AVLSet / BSTSet / LinkedListSet
				algorithm.study.avltree.test.TestSetMain
		
		AVL树的优化：
			增删改查操作都是：O(logn)
			在插入和删除操作的时候都会去计算高度，若当前节点的高度没有发生变化的时候，也不用去维护当前节点的祖先节点的高度。这个优化方案为实现！


红黑树：
	一种平衡的二叉树
	《算法导论》中的红黑树
		1、每个节点或者是红色的、或者是黑色的；
		2、根节点是黑色的；
		3、每一个叶子节点(最后的空节点)是黑色的；
		4、如果一个节点是红色的，那么它的孩子节点都是黑色的；(补充说明：一个黑色节点的右孩子一定是黑色的节点)
		5、从任意一个节点到叶子节点(最后的空节点)，经过的黑色节点是一样的；
	
	《算法4》
		红黑树与2-3树的等价性；理解了2-3树和红黑树之间的关系，红黑树就不难了。
	
	建议：学习2-3树，不仅对于理解红黑树有帮助，对于理解B类树(在数据结构中另外一类非常重要的数据结构，通常用于磁盘存储、文件系统、数据库相应的数据存储的数据结构)也是有巨大的帮助。	
	
	2-3树：
		1、满足二分搜索树的基本性质(但是在满足这个基本性质的基础上2-3树不是一种二叉树)
		2、2-3树有两种节点：可以存放一个元素 或者  两个元素(换句话说：每个节点有2个或者3个孩子 —— 2-3树)
			如：			a					b  c
					t1		t2			t3   t4	 t5
						2节点					3节点
			说明：满足二分搜索树的性质，t1 < a < t2
								t3 < b , b < t4 < c , c < t5
				
			实际例子：2-3树
									42
						[17 33]				50
				  [6 12]  18   37		 48	   [66 68]

		3、2-3树是一颗绝对平衡的树
			2-3树是如何维持绝对的平衡？以一个添加过程来讲解
				【对于2-3树添加节点来说，不会把一个新的节点添加到一个空节点上去，而是找到最后添加的那个位置的叶子节点做融合操作(直到达到四节点，再对这个四节点执行拆解操作)】
					实例说明：
						插入[42]:
											42
						插入[37]:从根节点出发添加元素；要是对于二分搜索树来说，插入37这个节点的过程是：从根节点出发，比42小，
								插入到42的左子树中(而42的左子树为空，37就将直接成为42的左孩子)；但是对于2-3树来说就不是这样了，
								【添加的节点将永远不会添加到一个空的位置上去，而是跟最后找到的节点融合】，因为42节点左子树为空，那么
								37这个节点将更最后一次找到的叶子节点融合，如下
											[37 42]
											
						插入[12]:按照常理来说，12比37小，应该插入到37的左子树中去，但是由于【添加节点将永远不会添加到一个空的位置上去，
								而是跟最后找到的节点融合】，因此如下（跟找到的叶子节点融合）
											[12 37 42]		- 先进行融合，形成了四节点。对于2-3树来说，不能有四节点，因此做
																拆解操作(分裂成一颗子树)，如下
															37
														12		42
														
						插入[18]:对于18来说，根节点为37，大于18，因此18插入到37的左子树中去；对与37的左子树12来说，18大于他，因此应该插入
								到12的右子树，由于12的右子树为空。故融合
												37
										[12 18]		42		- 因为12原来是2节点，融合18后变成三节点，没有破坏2-3树的性质。
										
						插入[6]:从根节点出发，6比37小，因此到左子树，对于左子树[12 18]来说，他们已经是三节点了。然而6比12还小，所以
								添加到三节点的左子树中去，但是左子树为空，做融合操作
												   37
										[6 12 18]		42		- 叶子节点若是已经为三节点，会暂时形成四节点，再做拆解操作
																
																- 按照之前的拆解方法(把他拆解为包含三个二节点的子树)，把临时的四节点中间的节点作为新的根节点
													37
											12				42
										6		18				- 如是拆解成这样，我们的2-3树就不是绝对平衡的二叉树了。
																	对于2-3树来说，如果一个叶子节点已经是一个三节点了，添加一个新的节点变成了一个四节点；
																	那么对于这个新的四节点，拆解成一颗新的子树时(中间的节点成为新的根节点)，存在一个新的
																	根节点[12];这个节点[12]要向上去和上面的父亲节点做融合操作。此时它的父节点为[37],
																	它是二节点，可直接融合 👇
												[12 37]	
											  6	  18   42
											  
						插入[11]:对于[12 37]这个根节点来说，11比12还小，因此插入到12的左子树中去,12的左子树是6这样一个二节点，11比6大，应该插入到右子树中去，
								但是由于【添加节点将永远不会添加到一个空的位置上去，而是跟最后找到的节点融合】。因此做融合操作
											[12 37]	
									[6 11]	  18    42
												
						插入[5]:	按照之前的步骤，应该为
												[12 37]	
									  [5 6 11]	  18    42		- 叶子节点若是已经为三节点，会暂时形成四节点，再做拆解操作
									
																- 按照之前的拆解方法(把他拆解为包含三个二节点的子树)
												[12 37]	
											6	  18    42			
										5	  11				- 依据插入[6]的说明，将拆解成的新的子树的根节点[6] 向上的父亲节点做融合操作
										
												[6 12 37]		- 由于根节点[6 12 37]形成了四节点。对于2-3树来说，不能有四节点，因此做
											5	11  18    42	 	拆解操作
											
												12				- 2-3树的最终效果
											6		37	
										  5   11  18  42	
														
		4、对于2-3树的插入节点操作来说：
			最重要的：	【添加的节点将永远不会添加到一个空的位置上去，而是跟最后找到的节点融合】											
			★：理解上面的实例👆									
		
		5、对于2-3树来说：
			从2-3树中的任意一个节点出发到叶子节点，所经过的节点数是一致的。【因为2-3树是绝对平衡的，所以所有的叶子节点都在同一层上，他们的深度是一致的】		
				
	红黑树与2-3树的等价性
		
		红黑树 与 2-3树
			2-3树：
				2节点			a						[a b]			3节点
						T1		T2				T1	  T2	T3
			红黑树：			
							a(黑色)					a —— b			- 说明：a连b之间的线为红色，但是在数据结构中，无法表示红色的线，因此将a节点变红
						T1		T2				T1	 T2		T3
													
														b(黑色)		- 三节点的红黑树表示
													a(红色)	T3		- 说明：红色节点 和它的 父亲节点，表示在元素2-3树中的3节点
												T1     T2			- 说明★：在红黑树中，所有的红色节点都是向左倾斜的

		实例转化：2-3树 ——> 红黑树
									42
						[17 33]				50
				[6 12]     18   37      48    [66 88]

									
									42
							33				50
						17(红色)	37		48		88
					12     18				 66(红色)
				6(红色)
	
	红黑树的基本性质与复杂度分析：
		《算法导论》中的红黑树
			1、每个节点或者是红色的、或者是黑色的；
			2、根节点是黑色的；
			3、每一个叶子节点(最后的空节点)是黑色的；
			4、如果一个节点是红色的，那么它的孩子节点都是黑色的；(补充说明：一个黑色节点的右孩子一定是黑色的节点)
			5、从任意一个节点到叶子节点(最后的空节点)，经过的黑色节点是一样的；
		补充：
			1、红黑树是保持“黑平衡”的二叉树。(说明：“黑平衡”是指从根节点开始搜索，一直搜索到叶子节点，所经历过的黑色节点的个数是一样多的)
			2、严格意义上、不是平衡二叉树。(但是它的左右子树的黑色节点的高度差保持着绝对平衡的)，最大的高度:2logn	O(logn)
			3、查找，相比AVL树要慢一些
				添加、删除 相比AVL树要快一些
				如：一些数据添加进去几乎不怎么去改动，只是用于查询的话；使用AVL树
	
	红黑树添加新元素：
		1、保持根节点为黑色节点
			插入[37]:当红黑树为空的时候，直接插入节点，最后维护下根节点为黑色
									37(红)
									↓
									37(黑)
			插入[30]:情况1、当插入的节点 小于 根节点的时候，按照二分搜索树的性质，直接插入到左子树中
									37(黑)
								30(红)
		2、左旋转过程
			但是当插入[42]:情况2、当插入节点 大于 根节点的时候，先按照二分搜索树的性质，直接插入到右子树中
									37(黑)
										42(红)		- 但是根据红黑树的性质【所有的红色节点都是向左倾斜的】，因此需要进行左旋转(将节点变为左孩子)
													
									42(黑)			- 左旋转得到的结果；左旋转过程 如下↓
								37(红)						37(黑) - node			node.right = x.left
														T1		42(红) - x			x.left = node
															  T2	T3
															  	
																👇
																
																42(红) - x			- 对节点的颜色进行维护
													node -	37(黑)	 T3					x.color = node.color
														T1		T2						node.color = RED
																
																👇
																
																42(黑) - x			- 注意：左旋转的过程中，不维护红黑树的性质。
													node -	37(红)	 T3					
														T1		T2				
																
			插入[66]:情况3、因为66比根节点大，因此为右节点
							原：		42(黑)
								37(红)
									
									42(黑)			
								37(红)	66(红)
								
								——> 对于2-3树而言
									原 	 	42(黑)		是三节点 [37 42]，现在插入66，临时变成四节点[37 42 66]，然后做分解操作：
										37(红)													42
																							37		66
								——> 对应在红黑树中，【三个2节点代表：就代表这三个节点其实都是黑色的节点；】
												每一个黑色的节点如果左侧没有红色的节点的话，它本身就代表一个单独的二节点
								此时我们的就不需要旋转，只需要改变颜色即可[颜色翻转]
		3、颜色翻转
									42(红)			
								37(黑)	66(黑)

			但是当插入[12]：情况4、因为12比根节点小，应该在其左侧
							原：		42(黑)
								37(红)
							插入：
									42(黑)			- 根据二分搜索树的性质
								37(红)
							12(红)
							
							——> 对于2-3树而言
								原 	 	42(黑)		是三节点 [37 42]，现在插入12，临时变成四节点[12 37 42]，然后做分解操作：
									37(红)														37
																							12		42
							——> 对应在红黑树中：引入另外一种操作【右旋转】

		4、右旋转过程
									42(黑)			- 插入[12]后的红黑树
								37(红)				- 做右旋转操作
							12(红)						node - 42(黑)
														x - 37(红)	T1
														12(红)	T2
													T3		T4
														
														👇
														
													  x - 37(红)						- node.left = x.right
													12(红)		42(黑) - node		  x.right = node
												T3		T4	 T2		T1
												
														👇
														
													  x - 37(黑)							- 对节点的颜色进行维护
													12(红)		42(红) - node		  		x.color = node.color
												T3		T4	 T2		T1						node.coloe = RED
														
														👇
														
													  x - 37(红)							- 对颜色进行翻转(如同情况3)
													12(黑)		42(黑) - node		  		
												T3		T4	 T2		T1	
								37(红)
							12(黑)	42(黑)			
	
		
			补充一种情况：
				插入[40]:因为40比根节点小，因此去左子树，但是由于比根节点的左子树大，因此再去右子树，如下
							原树：
									42(黑)
								37(红)
							插入：
									42(黑)					- 在这种情况下，先进行做左旋转
								37(红)
									40(红)
									
									42(黑)					- 在这种情况下，先进行做左旋转
								40(红)
							37(红)


									40(黑)					- 在这种情况下，先进行做右旋转
								37(红)	42(红)

				
									40(红)					- 在这种情况下，再进行颜色的翻转
								37(黑)	42(黑)

			★总结说明：
							插入			        左旋转				      右旋转 				颜色翻转
					黑		——>		黑		——>			黑		——>		黑		——>		红
				红				红					红				红		红		黑		黑
									红			红
				原始				步骤1					步骤2					步骤3				步骤4
				
				情况分析：
					原始举例为：		42(黑)
								37(红)
						1、当插入节点为[40]时，插入后的情况如同步骤1；维护红黑树的步骤：
							从插入后的状态开始(步骤1) ——> 步骤2 ——> 步骤3 ——> 步骤4	
							
						2、当插入节点为[30]时，插入后的情况如同步骤2；维护红黑树的步骤：
							从插入后的状态开始(步骤2) ——> 步骤3 ——> 步骤4
							
						3、当插入节点为[50]时，插入后的情况如同步骤3；维护红黑树的步骤：
							从插入后的状态开始(步骤3) ——> 步骤4		

	红黑树中的删除节点：
		为学。需要自己去学

	测试性能：
		二分搜索树 / AVL树 / 红黑树
			algorithm.study.rbtree.test.Main	// 综合测试(词频统计)
			algorithm.study.rbtree.test.Main2	// 随机添加元素
			algorithm.study.rbtree.test.Main3	// 有序添加元素
		性能总结：
			1、对于完全随机的数据，普通的二分搜索树很好用
				缺点：极端情况退化成链表(或者高度不平衡；有序)
			2、对于查询较多的使用情况，AVL树很好用
			3、红黑树牺牲了平衡性(2logn的高度)
				统计性能更优(综合增删改查所有的操作)
					如TreeMap / TreeSet 底层都是红黑树
				另一种统计性能优秀的树结构：Splay Tree(伸展树)
					局部性原理：刚被访问的内容下次高概率被再次访问
					
	补充红黑树：
			2-3树：
				2节点			a						[a b]			3节点
						T1		T2				T1	  T2	T3
					
			红黑树：第一种
							a(黑)						b(黑)		- 这种叫“左倾红黑树”
						T1		T2					a(红)	T3
												T1	  T2
			红黑树：第二种
							a(黑)						a(黑)		- 这种叫“右倾红黑树”
						T1		T2					T1		b(红)	
														 T2	  T3
			
哈希表：
	从一个简单的问题开始：
		leetcode387. 字符串中的第一个唯一字符
			给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
				案例：
					s = "leetcode"
					返回 0.
					s = "loveleetcode",
					返回 2.
	哈希表充分体现了算法设计领域的经典思想：空间换时间
	
	哈希函数的设计：
		整型：
			小范围正整数直接使用
			小范围负整数进行偏移		-100 ~ 100  ——> 0 ~ 200
			
			大整数
			身份证号码：110108198512166666 ——> 	11010819851216[6666]
				通常做饭：取模		比如，取后四位。等同于 mod 1000 
				一个简单的解决办法：模一个素数
					例如：
						10 % 4 ——> 2		10 % 7 ——> 3
						20 % 4 ——> 0		20 % 7 ——> 6
						30 % 4 ——> 2		30 % 7 ——> 2
						40 % 4 ——> 0		40 % 7 ——> 4
						50 % 4 ——> 2		50 % 7 ——> 1
					当数据有一定规律	，模和数会冲突，模素数得到的结果更好。
					在于这个素数该怎么取？取多大？参考：
						http://planetmath.org/goodhashtableprimes
			
		浮点型：
			在计算机中都是32位或者64位的二进制表示，只不过计算机解析成了浮点数
				如果我们的键是浮点型的话，我们就可以使用这个浮点型所存储的这个空间把它当作是整型来处理(也就是我们把这个浮点数所占用的32位/64位空间使用整数的方式来解析)；
			之后就可以转成(将一个大的整数转化位索引的方式，取模的方式)
		
		字符串：
			同样也可以转化成整型来处理。
			例如：
				166 = 1 * 10^2 + 6 * 10^1 + 6 * 10^0
					↓
					可以理解成每个数字的十进制表示法(我们也可以把整数看成是一个字符串，每一个字符就是一个数字)
				code = c * 26^3 + o * 26^2 + d * 26^1 + e * 26^0
					↓
					同理，可以把它想成26进制的整数；内存中表示地址和颜色都是使用16进制的表示法；这样一来我们就可以把一个字符串看成是一个26进制的大的整型(这里为什么用26，因为是有26个小写字母)。
					 如果字符串更复杂的时候，我们看出26进制是不够的；因此可以让用户自己指定多少进制(B进制)？
					 	code = c * B^3 + o * B^2 + d * B^1 + e * B^0
					↓ code这个字符串经过hash函数的结果
				hash(code) = (c * B^3 + o * B^2 + d * B^1 + e * B^0) % M
					↓ B^K,如果这个k比较大的话，我们的计算过程也比较慢，因此需要转化为
				hash(code) = ((((c) * B + o) * B + d) * B + e) % M
					↓ 我们算出来的大整型可能会造成整型的溢出，所以将取模的过程挪到括号的里面
				hash(code) = ((((c % M) * B + o) % M * B + d) % M * B + e) % M 
					下 字符串对应的程序
				int hash = 0
				for(int i = 0 ; i < str.length() ; i ++){
					hash = (hash * B + s.charAt(i)) % M;
				}

		复合类型：
			转成整型处理
			
			同样参照字符串的处理方式：
				hash(code) = ((((c % M) * B + o) % M * B + d) % M * B + e) % M
			我们有个日期类(Date:year,month,day):
				hash(date) = (((Date.year % M) * B + Date.month) % M * B + Date.day) % M
		
		注意：对于哈希函数的设计，转成整型处理，并不是唯一的方法。这只是比较常用、通用的办法。
			对于哈希函数的设计来说，需要遵守的原则：
				1、一致性：如果a == b，则hash(a) == hash(b)
				2、高效性：计算高效简便
				3、均匀性：哈希值均匀分布(我们这里的采用的办法是：模上一个素数)
	
	
	java中的hashCode
		algorithm.study.hashjava.Main
	
	哈希冲突的处理——链地址法(Seperate Chaining)
		前提：
			如一个元素为：k1 ——> hashCode(k1) % M
						在java中，hashCode()得到的值也许是负值，为了解决这个问题，通常在java中对这个结果我们还要将负号抹去。
						抹去负号的方式：
							1、 |hashCode(k1)| % M，对它求个绝对值
							2、(hashCode(k1) & 0x7fffffff) % M
								说明：做一个按位与操作，在16进制的表示法中，每一位表示4个bit；相应的f表示四个1(f --> 1111),7表示三个1(7 --> 111),
									因此：0x7fffffff ——>	111 1111 1111 1111 1111 1111 1111 1111	(31个1)
									(hashCode(k1)这个整型 与 31个1 做按位与 操作)：在计算机中，整型的表示是用32位，其中最高位 为符号位。
									0x7fffffff的最高位为0，hashCode(k1)这个整型所表示的最高位的1抹去(因为最高位为符号位，1表示负数，0表示正数);这样
									一个操作将最高位的1变成了0(相当于把符号去掉了)
		
		数组表示：
			索引：
				0	——> 			
				1	——> 
				2	——> k1 ——> k3		- 原来这个索引位置已经存在了一个k1，现在又来一个k3，我们直接把它做成链表(换句话说：这种哈希冲突的处理方式实际上就是对于这个哈希表，我们开M个空间，对于这M个空间，每个空间由于有哈希冲突的存在，所以本质上它就是存储一个链表。) 
				3	——> 				- 	这里说每个位置存储一个链表，其实对于它的本质是存储一个查找表(查找表也可以使用平衡树结构)；如下变形
				4	——> k2
				5	——> 
				6	——> 
				M-1	——> 
			插入：
				k1,k2,k3；经过上面那种算索引的方法，得出k1索引为2，k2索引为4，k3与k1索引冲突
				
 					0	——> TreeMap			
					1	——> TreeMap
					2	——> TreeMap	
					3	——> TreeMap				
					4	——> TreeMap
					5	——> TreeMap
					6	——> TreeMap
					M-1	——> TreeMap
					当插入元素的时候，先计算出对应的hash值所对应的索引，然后找到这个索引位置的TreeMap，将这个元素插入到TreeMap就好了。
					补充：
						HashMap 就是一个 TreeMap(底层是红黑树) 数组
						HashSet 就是一个 TreeSet 数组
						java8之前，每一个位置对应一个链表
						java8开始，在初始的时候，这个hash表的每一个位置依然是一个链表，但是当哈希冲突达到一定程度(链表大于8，也就是冲突大于8)，那么就会把每一个位置从链表转换为红黑树
							说明：数据量小的时候，链表的操作比较快；
			
		性能比较：
			测试二分搜索树 / AVL树 / 红黑树	/ hash表(HashTable)
				algorithm.study.hash.test.Main
			得出一个结论：
				哈希表的空间大小(M，素数)直接影响着性能，该如何处理这个大小啦？如下讲解
		
	哈希表的动态空间处理和时间复杂度分析：
		algorithm.study.hash.HashTable<K, V>
			时间复杂度分析：
				总共有M个地址，如果放入哈希表的元素个数为N；
				如果每个地址是链表：O(N/M)
				如果每个地址是平衡树：O(log(N/M))
				如何让复杂度达到O(1)级别？
					答：和静态数组一样，固定地址空间是不合理的；需要自动扩容(resize()),说明：哈希表与数组是不同的，对于数组来说元素是一个一个填满这些
					空间，然而对于哈希表来说每一个地址其实代表了每一个hash值对应的位置，所以当我们这个M个空间开辟出来后，从某种
					意义上讲相当于这M个空间都被占据上了，每一个位置代表的就是一个hash值对应的后续的一个查找表(链表也好，还是平衡树也好)；
					所以我们不能向动态数组那样，我们不能判定当我们插入的元素装满了数组的时候就扩容。但是在使用(哈希冲突的处理——链地址法)
					这个情况下，是不存在元素填满这些空间的说法的；
					因而实际处理的逻辑为：平均每个地址承载的元素多个一定程度，即扩容 N / M >= upperTol,也就是我设置一个上界，如果我们整个hash表中
						元素总数 / 当前地址数 >= 这个上界，此时就意味着平均每个地址相应的hash冲突的元素至少都已经有upperTol这么多个了。
									平均每个地址承载的元素少过一定程度，即缩容 N / M < lowerTol,
		实际的扩容/缩容函数：			
			algorithm.study.hash.HashTable.resize(int)
	
	哈希表更复杂的动态空间处理方法：
		总结扩容/缩容后的时间复杂度
			回忆动态数组的均摊复杂度分析，平均复杂度O(1)
			对于哈希表来说，元素数从N增加到upperTol * N；地址空间增倍，平均复杂度O(1)，实际的：每个操作在O(lowerTol) ~ O(upperTol) ——> O(1),均摊复杂度得到的
		更复杂的动态空间处理方法：
			扩容：M -> 2 * M，扩容后2*M不是素数了，如何去保证哈希值均匀分布？
			解决方案：
				参考http://planetmath.org/goodhashtableprimes这个网站提供大小去扩容，若需要扩容时，先扩容到53，再满足时，再扩容到97，以此类推
 			algorithm.study.hashmore.HashTable<K, V>
		
		性能对比：
			扩容/缩容大小维护在原来的两倍  比  扩容/缩容大小维护在素数 性能要低一些。
	
		哈希表：均摊复杂度为O(1)，那么它牺牲了什么？顺序性
		
							集合，映射
				有序集合，有序映射		无序集合，无序映射
					↓ 底层实现				↓ 底层实现
					平衡树				哈希表
					↓ java标准库中			↓ java标准库中
				TreeSet、TreeMap		HashSet、HashMap
		总结：
			这里我们写的HashTable，底层是基于TreeMap的；
			由于public class HashTable<K,V>	中的key不要求Comparable，可比性
				但是底层的private TreeMap<K,V>[] hashtable; 这个key要求Comparable。
			在这里就产生了矛盾，这里有个Bug的存在！！！
		
		练习：未完成
			完成一个java8开始，在初始的时候，这个hash表的每一个位置依然是一个链表，但是当哈希冲突达到一定程度(链表大于8，也就是冲突大于8)，那么就会把每一个位置从链表转换为红黑树
			简单来说:初始的时候是链表，达到一定程度时转换为红黑树。

	更多哈希冲突的处理方法：
		链地址法(Seperate Chaining)：
			。。。。
		开放地址法(Open Addressing)：
			线性探测法：遇到哈希冲突时，(若当前位置被占用，直接位置+1，以此类推)
			平方探测法：遇到哈希冲突时，(若当前位置被占用，直接位置+1；如还是被占，直接地址+4；如还是被占，直接地址+9；如还是被占，直接地址+16；以此类推)
			二次哈希法：遇到哈希冲突时，运用下一个hash2(key)函数再去计算位置
			说明：在开放地址法中，当负载率(元素总数/地址总数)大于一定程度时，扩容。
		再哈希法(Rehashing):	
			当我们使用一个hash函数产生的索引，这个索引发生冲突后，我们利用另外一个哈希函数去找相应的索引。
		Coalessed Hashing:
			综合了Seperate Chaining 和 Open Addressing


总结：
	线性结构：动态数组、普通队列、栈、链表、哈希表
	树形结构：二分搜索树(二叉树：堆、线段树；多叉树：Trie、并查集)、AVL树、红黑树(先懂2-3树)	
	图结构：邻接表、邻接矩阵
	
	更多的数据结构：
		队列：双端队列、随机队列、最大最小队列
		链表：双向链表、循环链表
		树：K-D树、Splay树、B树
		跳跃表、后缀数组。。。。



			